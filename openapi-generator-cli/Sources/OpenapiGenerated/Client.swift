// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
import HTTPTypes
/// 테스트 프로덕션용 NOFFICE API 명세서입니다.
/// 공통된 응답 형식은 Schemas-NofficeResponseString을 참고해주세요.
public struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    public init(
        serverURL: Foundation.URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter {
        client.converter
    }
    /// 투두 목록 조회
    ///
    /// - Remark: HTTP `GET /api/v1/tasks`.
    /// - Remark: Generated from `#/paths//api/v1/tasks/get(getTasks)`.
    public func getTasks(_ input: Operations.getTasks.Input) async throws -> Operations.getTasks.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getTasks.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/tasks",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 255:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getTasks.Output.Code255.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .code255(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getTasks.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init()
                    )
                }
            }
        )
    }
    /// 투두 생성
    ///
    /// - Remark: HTTP `POST /api/v1/tasks`.
    /// - Remark: Generated from `#/paths//api/v1/tasks/post(createTask)`.
    public func createTask(_ input: Operations.createTask.Input) async throws -> Operations.createTask.Output {
        try await client.send(
            input: input,
            forOperation: Operations.createTask.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/tasks",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "taskCreateRequest",
                    value: input.query.taskCreateRequest
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 215:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createTask.Output.Code215.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .code215(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createTask.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init()
                    )
                }
            }
        )
    }
    /// 투두 대량 생성
    ///
    /// - Remark: HTTP `POST /api/v1/tasks/bulk`.
    /// - Remark: Generated from `#/paths//api/v1/tasks/bulk/post(createBulkTask)`.
    public func createBulkTask(_ input: Operations.createBulkTask.Input) async throws -> Operations.createBulkTask.Output {
        try await client.send(
            input: input,
            forOperation: Operations.createBulkTask.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/tasks/bulk",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "taskBulkCreateRequest",
                    value: input.query.taskBulkCreateRequest
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 215:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createBulkTask.Output.Code215.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .code215(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createBulkTask.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init()
                    )
                }
            }
        )
    }
    /// 조직 생성
    ///
    /// - Remark: HTTP `POST /api/v1/organization`.
    /// - Remark: Generated from `#/paths//api/v1/organization/post(createOrganization)`.
    public func createOrganization(_ input: Operations.createOrganization.Input) async throws -> Operations.createOrganization.Output {
        try await client.send(
            input: input,
            forOperation: Operations.createOrganization.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/organization",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createOrganization.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init()
                    )
                }
            }
        )
    }
    /// 멤버의 조직 가입
    ///
    /// - Remark: HTTP `POST /api/v1/organization/{organizationId}/join`.
    /// - Remark: Generated from `#/paths//api/v1/organization/{organizationId}/join/post(joinOrganization)`.
    public func joinOrganization(_ input: Operations.joinOrganization.Input) async throws -> Operations.joinOrganization.Output {
        try await client.send(
            input: input,
            forOperation: Operations.joinOrganization.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/organization/{}/join",
                    parameters: [
                        input.path.organizationId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.joinOrganization.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init()
                    )
                }
            }
        )
    }
    /// 사용자에게 수신된 알림 조회
    ///
    /// 사용자에게 수신된 알림을 조회합니다.
    ///
    /// - Remark: HTTP `GET /api/v1/notifications`.
    /// - Remark: Generated from `#/paths//api/v1/notifications/get(getNotifications)`.
    public func getNotifications(_ input: Operations.getNotifications.Input) async throws -> Operations.getNotifications.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getNotifications.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/notifications",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "memberId",
                    value: input.query.memberId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 207:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getNotifications.Output.Code207.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .code207(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getNotifications.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init()
                    )
                }
            }
        )
    }
    /// 단일 사용자 알림 대기열 추가
    ///
    /// 단일 사용자를 특정하여 노티 알림 대기열에 등록합니다.
    ///
    /// - Remark: HTTP `POST /api/v1/notifications`.
    /// - Remark: Generated from `#/paths//api/v1/notifications/post(createNotification)`.
    public func createNotification(_ input: Operations.createNotification.Input) async throws -> Operations.createNotification.Output {
        try await client.send(
            input: input,
            forOperation: Operations.createNotification.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/notifications",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 207:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createNotification.Output.Code207.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .code207(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createNotification.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init()
                    )
                }
            }
        )
    }
    /// 알림 발송 시간 변경
    ///
    /// 노티 알림 발송 시간을 변경합니다.
    ///
    /// - Remark: HTTP `PATCH /api/v1/notifications`.
    /// - Remark: Generated from `#/paths//api/v1/notifications/patch(changeSendTime)`.
    public func changeSendTime(_ input: Operations.changeSendTime.Input) async throws -> Operations.changeSendTime.Output {
        try await client.send(
            input: input,
            forOperation: Operations.changeSendTime.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/notifications",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 207:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.changeSendTime.Output.Code207.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .code207(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.changeSendTime.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init()
                    )
                }
            }
        )
    }
    /// 조직 단위 알림 대량 발송
    ///
    /// 조직 내 모든 사용자에게 전체 발송되는 알림을 등록합니다.
    ///
    /// - Remark: HTTP `POST /api/v1/notifications/bulk`.
    /// - Remark: Generated from `#/paths//api/v1/notifications/bulk/post(createBulkNotification)`.
    public func createBulkNotification(_ input: Operations.createBulkNotification.Input) async throws -> Operations.createBulkNotification.Output {
        try await client.send(
            input: input,
            forOperation: Operations.createBulkNotification.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/notifications/bulk",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 207:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createBulkNotification.Output.Code207.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .code207(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createBulkNotification.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init()
                    )
                }
            }
        )
    }
    /// 토큰 재발급
    ///
    /// 리프레시 토큰을 이용해 새로운 액세스 토큰을 발급합니다.
    ///
    /// - Remark: HTTP `POST /api/v1/member/reissue`.
    /// - Remark: Generated from `#/paths//api/v1/member/reissue/post(reissue)`.
    public func reissue(_ input: Operations.reissue.Input) async throws -> Operations.reissue.Output {
        try await client.send(
            input: input,
            forOperation: Operations.reissue.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/member/reissue",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.reissue.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init()
                    )
                }
            }
        )
    }
    /// 회원 로그인
    ///
    /// 본문에 소셜 공급자명과 인가코드를 넣어 노피스 서버 로그인을 시도합니다.
    ///
    /// - Remark: HTTP `POST /api/v1/member/login`.
    /// - Remark: Generated from `#/paths//api/v1/member/login/post(login)`.
    public func login(_ input: Operations.login.Input) async throws -> Operations.login.Output {
        try await client.send(
            input: input,
            forOperation: Operations.login.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/member/login",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.login.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init()
                    )
                }
            }
        )
    }
    /// 모든 노티 조회
    ///
    /// 사용자에게 할당된 모든 노티를 조회합니다.
    ///
    /// - Remark: HTTP `GET /api/v1/announcement`.
    /// - Remark: Generated from `#/paths//api/v1/announcement/get(getAnnouncements)`.
    public func getAnnouncements(_ input: Operations.getAnnouncements.Input) async throws -> Operations.getAnnouncements.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAnnouncements.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/announcement",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 205:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAnnouncements.Output.ResetContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .resetContent(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAnnouncements.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init()
                    )
                }
            }
        )
    }
    /// 노티 생성
    ///
    /// 노티를 생성합니다.
    ///
    /// - Remark: HTTP `POST /api/v1/announcement`.
    /// - Remark: Generated from `#/paths//api/v1/announcement/post(createAnnouncement)`.
    public func createAnnouncement(_ input: Operations.createAnnouncement.Input) async throws -> Operations.createAnnouncement.Output {
        try await client.send(
            input: input,
            forOperation: Operations.createAnnouncement.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/announcement",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 215:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createAnnouncement.Output.Code215.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .code215(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createAnnouncement.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init()
                    )
                }
            }
        )
    }
    /// 노티 조회
    ///
    /// 노티를 조회합니다.
    ///
    /// - Remark: HTTP `GET /api/v1/announcement/{announcementId}`.
    /// - Remark: Generated from `#/paths//api/v1/announcement/{announcementId}/get(getAnnouncement)`.
    public func getAnnouncement(_ input: Operations.getAnnouncement.Input) async throws -> Operations.getAnnouncement.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAnnouncement.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/announcement/{}",
                    parameters: [
                        input.path.announcementId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 205:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAnnouncement.Output.ResetContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .resetContent(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAnnouncement.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init()
                    )
                }
            }
        )
    }
    /// 노티 수정
    ///
    /// 노티를 수정합니다.
    ///
    /// - Remark: HTTP `POST /api/v1/announcement/{announcementId}`.
    /// - Remark: Generated from `#/paths//api/v1/announcement/{announcementId}/post(updateAnnouncement)`.
    public func updateAnnouncement(_ input: Operations.updateAnnouncement.Input) async throws -> Operations.updateAnnouncement.Output {
        try await client.send(
            input: input,
            forOperation: Operations.updateAnnouncement.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/announcement/{}",
                    parameters: [
                        input.path.announcementId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 205:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.updateAnnouncement.Output.ResetContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .resetContent(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.updateAnnouncement.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init()
                    )
                }
            }
        )
    }
    /// 노티 삭제
    ///
    /// 노티를 삭제합니다.
    ///
    /// - Remark: HTTP `DELETE /api/v1/announcement/{announcementId}`.
    /// - Remark: Generated from `#/paths//api/v1/announcement/{announcementId}/delete(deleteAnnouncement)`.
    public func deleteAnnouncement(_ input: Operations.deleteAnnouncement.Input) async throws -> Operations.deleteAnnouncement.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteAnnouncement.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/announcement/{}",
                    parameters: [
                        input.path.announcementId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 205:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.deleteAnnouncement.Output.ResetContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .resetContent(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.deleteAnnouncement.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init()
                    )
                }
            }
        )
    }
    /// 서버 상태 확인
    ///
    /// 정상 동작시 OK 반환합니다.
    ///
    /// - Remark: HTTP `GET /health`.
    /// - Remark: Generated from `#/paths//health/get(health)`.
    public func health(_ input: Operations.health.Input) async throws -> Operations.health.Output {
        try await client.send(
            input: input,
            forOperation: Operations.health.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/health",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.health.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init()
                    )
                }
            }
        )
    }
    /// 사용자 할당 투두 목록 조회
    ///
    /// - Remark: HTTP `GET /api/v1/tasks/assigned`.
    /// - Remark: Generated from `#/paths//api/v1/tasks/assigned/get(getAssignedTasks)`.
    public func getAssignedTasks(_ input: Operations.getAssignedTasks.Input) async throws -> Operations.getAssignedTasks.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAssignedTasks.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/tasks/assigned",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "memberId",
                    value: input.query.memberId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pageable",
                    value: input.query.pageable
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 205:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAssignedTasks.Output.ResetContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .resetContent(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAssignedTasks.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init()
                    )
                }
            }
        )
    }
    /// 단일 조직 정보 조회
    ///
    /// - Remark: HTTP `GET /api/v1/organization/{organizationId}`.
    /// - Remark: Generated from `#/paths//api/v1/organization/{organizationId}/get(getOrganization)`.
    public func getOrganization(_ input: Operations.getOrganization.Input) async throws -> Operations.getOrganization.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getOrganization.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/organization/{}",
                    parameters: [
                        input.path.organizationId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getOrganization.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init()
                    )
                }
            }
        )
    }
    /// 조직 목록 조회
    ///
    /// - Remark: HTTP `GET /api/v1/organization/list`.
    /// - Remark: Generated from `#/paths//api/v1/organization/list/get(getOrganizationList)`.
    public func getOrganizationList(_ input: Operations.getOrganizationList.Input) async throws -> Operations.getOrganizationList.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getOrganizationList.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/organization/list",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getOrganizationList.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init()
                    )
                }
            }
        )
    }
    /// 단일 회원 정보 조회
    ///
    /// - Remark: HTTP `GET /api/v1/member/{memberId}`.
    /// - Remark: Generated from `#/paths//api/v1/member/{memberId}/get(getMember)`.
    public func getMember(_ input: Operations.getMember.Input) async throws -> Operations.getMember.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getMember.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/member/{}",
                    parameters: [
                        input.path.memberId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getMember.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init()
                    )
                }
            }
        )
    }
    /// 멤버가 가입한 조직 목록 조회
    ///
    /// - Remark: HTTP `GET /api/v1/member/{memberId}/organizations`.
    /// - Remark: Generated from `#/paths//api/v1/member/{memberId}/organizations/get(getJoinedOrganizations)`.
    public func getJoinedOrganizations(_ input: Operations.getJoinedOrganizations.Input) async throws -> Operations.getJoinedOrganizations.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getJoinedOrganizations.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/member/{}/organizations",
                    parameters: [
                        input.path.memberId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getJoinedOrganizations.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init()
                    )
                }
            }
        )
    }
    /// 전체 카테고리 조회
    ///
    /// - Remark: HTTP `GET /api/v1/category`.
    /// - Remark: Generated from `#/paths//api/v1/category/get(getCategories)`.
    public func getCategories(_ input: Operations.getCategories.Input) async throws -> Operations.getCategories.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getCategories.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/category",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getCategories.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init()
                    )
                }
            }
        )
    }
    /// 특정 조직의 카테고리 조회
    ///
    /// - Remark: HTTP `GET /api/v1/category/organization/{organizationId}`.
    /// - Remark: Generated from `#/paths//api/v1/category/organization/{organizationId}/get(getCategoriesByOrganization)`.
    public func getCategoriesByOrganization(_ input: Operations.getCategoriesByOrganization.Input) async throws -> Operations.getCategoriesByOrganization.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getCategoriesByOrganization.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/category/organization/{}",
                    parameters: [
                        input.path.organizationId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getCategoriesByOrganization.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init()
                    )
                }
            }
        )
    }
    /// 노티에 발행된 알림 개수 조회
    ///
    /// 노티에 발행된 알림 개수를 조회합니다.
    ///
    /// - Remark: HTTP `GET /api/v1/announcement/{announcementId}/count`.
    /// - Remark: Generated from `#/paths//api/v1/announcement/{announcementId}/count/get(getNotificationCount)`.
    public func getNotificationCount(_ input: Operations.getNotificationCount.Input) async throws -> Operations.getNotificationCount.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getNotificationCount.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/announcement/{}/count",
                    parameters: [
                        input.path.announcementId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 207:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getNotificationCount.Output.Code207.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .code207(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getNotificationCount.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init()
                    )
                }
            }
        )
    }
    /// 투두 삭제
    ///
    /// - Remark: HTTP `DELETE /api/v1/tasks/{taskId}`.
    /// - Remark: Generated from `#/paths//api/v1/tasks/{taskId}/delete(deleteTask)`.
    public func deleteTask(_ input: Operations.deleteTask.Input) async throws -> Operations.deleteTask.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteTask.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/tasks/{}",
                    parameters: [
                        input.path.taskId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 215:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.deleteTask.Output.Code215.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .code215(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.deleteTask.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init()
                    )
                }
            }
        )
    }
    /// 알림 삭제
    ///
    /// 노티 알림을 삭제합니다.
    ///
    /// - Remark: HTTP `DELETE /api/v1/notifications/{notificationId}`.
    /// - Remark: Generated from `#/paths//api/v1/notifications/{notificationId}/delete(deleteNotification)`.
    public func deleteNotification(_ input: Operations.deleteNotification.Input) async throws -> Operations.deleteNotification.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteNotification.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/notifications/{}",
                    parameters: [
                        input.path.notificationId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 207:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.deleteNotification.Output.Code207.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .code207(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.deleteNotification.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init()
                    )
                }
            }
        )
    }
}
